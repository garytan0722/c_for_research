#include <stdio.h>#include <pcap.h>#include <net/ethernet.h>#include <netinet/ip.h>#include <arpa/inet.h>#include <string.h>#include <sys/stat.h>#include <sys/time.h>#include <unistd.h>#include <signal.h>#include <fcntl.h> #include <stdlib.h>#define CURL_STATICLIB#include <curl/curl.h>#include <sys/system_properties.h>void pcap_callback(u_char *arg, const struct pcap_pkthdr *header,const u_char *content);double now_ms();void breakloop();void post(char path[], char imei_start[]);pcap_t *handle;int main(int argc, const char * argv[]) {	char errbuf[PCAP_ERRBUF_SIZE];	char *dev;	pcap_dumper_t *pd;	dev = pcap_lookupdev(errbuf);	char path[30];	char unixtime[30];    char *filename;    char *search = ".";    char imei_start[15];	handle = pcap_open_live(dev,65535,1,1, errbuf);	if(!handle){        printf("%s\n",errbuf);        return -1;    }    bpf_u_int32 net_ip,netmask;    struct bpf_program bpf;    pcap_lookupnet(dev, &net_ip, &netmask ,errbuf);    pcap_compile(handle,&bpf, "port 80 || port 443",1, netmask);    pcap_setfilter(handle, &bpf);    double sec=now_ms();    printf("Time:%f\n",sec);    sprintf(unixtime,"%f\n",sec);    printf("Unixtime: %s\n",unixtime);    filename=strtok(unixtime,search);    printf("FileName: %s\n",filename);    sprintf(path,"/tmp/%s.pcap",filename);    printf("error");    printf("PATH:%s\n",path);     if((pd = pcap_dump_open(handle,path)) == NULL){         printf("Can not open pcap file error!!");     }     signal(SIGALRM, breakloop);     alarm(10);    pcap_loop(handle,-1,pcap_callback, (u_char*)pd);    pcap_dump_close(pd);    pcap_close(handle);    printf("Close dump\n");    int ir = __system_property_get("ro.gsm.imei", imei_start);               if(ir > 0)    {     		printf("Got imei %s len %d\r\n",imei_start,strlen(imei_start));           }else{         strcpy(imei_start,"flase");     }     //Curl post pcap     post(path,imei_start);}void pcap_callback(u_char *arg, const struct pcap_pkthdr *header,const u_char *content){    pcap_dump(arg,header,content);}double now_ms(void) {    struct timespec res;    clock_gettime(CLOCK_REALTIME, &res);    return res.tv_sec;}void breakloop(){    pcap_breakloop(handle);}void post(char path[], char imei_start[]){	CURL *curl;    CURLcode res;    char command[30];	struct curl_httppost *post=NULL;    struct curl_httppost *last=NULL;    double speed_upload, total_time;	char *url="https://s1.nrl.mcu.edu.tw/04166076/testcurl/curl.php";	curl = curl_easy_init();    if (curl) {        curl_formadd(&post, &last,                     CURLFORM_COPYNAME, "file",                     CURLFORM_FILE,path,                     CURLFORM_END);        curl_formadd(&post, &last,                     CURLFORM_COPYNAME, "imei",                     CURLFORM_COPYCONTENTS,imei_start,                     CURLFORM_END);        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYHOST, 0L);        curl_easy_setopt(curl, CURLOPT_SSL_VERIFYPEER, 0L);        curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);        curl_easy_setopt(curl, CURLOPT_URL, url);        curl_easy_setopt(curl, CURLOPT_HTTPPOST, post);        res = curl_easy_perform(curl);        if(res != CURLE_OK) {            fprintf(stderr, "curl_easy_perform() failed: %s\n",                    curl_easy_strerror(res));            //printf("file:",);                    }        else {            /* now extract transfer info */            curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &speed_upload);            curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &total_time);            fprintf(stderr, "Speed: %.3f bytes/sec during %.3f seconds\n",                    speed_upload, total_time);        }        curl_formfree(post);    }    curl_easy_cleanup(curl);    sprintf(command,"rm %s && ./monitor.bin",path);    system(command);}